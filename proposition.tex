\section{Amélioration de la recette fonctionnelle d'une application}

Effectuée manuellement, la recette fonctionnelle d'une application peut s'avérer longue et fastidieuse, notamment si l'application est régulièrement mise à jour, les tests devant être effectués de manière régulière au fur et à mesure des mises à jour. Elle peut donc être source de perte de temps et surtout représenter un coût non négligeable pour une entreprise.\newline
L'objectif de l'amélioration de la recette fonctionnelle est donc de réduire le coût engendré par celle-ci. Pour ce faire, il est impératif d'effectuer une automatisation judicieuse des différents cas de tests permettant de couvrir le plus grand nombre de fonctionnalités présentes au sein du logiciel.\medbreak
Cependant, il est possible de pousser plus loin l'automatisation de la recette. En effet, même si mettre en place des suites de tests automatisés demeure un réel progrès dans le déroulement des recettes, cette pratique nécéssite toutefois des interventions humaines lors de son déroulement (lancements et suivis des tests) et seul l'AMOA est en connaissance des résultats obtenus qu'ils soient positifs ou négatifs. L'ensemble de la recette n'est donc pas totalement automatisé. Pour parfaire le processus de recette et ainsi obtenir un résultat intégralement automatisé et accessible à chacun des membres d'une équipe de projet, intégrer ces tests au sein du processus d'intégration continue utilisé pour le développement de l'application est possible et présente différents avantages.\medbreak
En effet, elle permet aux membres de la MOE d'avoir connaissance du résultat des tests de l'application au niveau fonctionnel, sans intervention d'assistant à maitrise d'ouvrage, car l'outil d'intégration continue informe en temps réel du résultat des tests mis en place par ce dernier. Ainsi, ce procédé engendre une économie de temps non-négligeable lors d'une livraison. De plus, elle permet de signaler les régressions intervenues lors de chacune des modifications effectuées au niveau du code sans avoir à vérifier le comportement de l'application étant donné que les tests automatisés vont vérifier le comportement de l'application.

\section{Tests automatisés et intégration continue}

Gratuit, simple à prendre en main et très fonctionnel, Selenium demeure un outil de choix afin de mettre en place une automatisation des tests fonctionnels. Il permet en effet d'effectuer des tests robustes, joués automatiquement de manière régulière afin de detecter une regression ou une erreur fonctionnelle. \newline
Néanmoins, Selenium souffre d'un défaut majeur: s'il est utlisé seul, il ne communique pas les résultats des tests effectués en dehors de la fenêtre de l'application. En effet, l'outil n'envoie pas de mail, n'affiche pas de notification à l'utilisateur. Le résultat d'un test n'est visible qu'en consultant la fenêtre de l'application une fois un test terminé. En outre, il n'indique pas non plus qu'un test est terminé, à l'aide d'une notification par exemple, obligeant ainsi ses utilisateurs à observer régulièrement son activité. \newline
Afin de pallier ce problème, il est possible d'intégrer le déroulement des tests effectués avec Selenium au sein de la plateforme d'intégration continue Jenkins. En effet, ce dernier peut lui même exécuter les tests Selenium, prendre en compte les résultats de ces derniers et en informer rapidement l'équipe du projet. \medbreak

\subsection{Mise en place des tests automatisés avec Selenium}
Afin de remplir leur rôle de la manière la plus optimale qui soit, les tests automatisés doivent couvrir un large éventail de fonctionnalités tout en étant simple à maintenir. \newline
En effet, des tests complexes à maintenir seront vite obsolètes et donc inutilisables. Cette étape constitue la plus longue à effectuer et ne demeure réalisable qu'après la développement d'une fonctionnalité car il s'avère impossible de mettre en place des tests automatisés d'une fonctionnalité logicielle tant que celle-ci n'est pas développée, les tests étant basés sur le code et l'interface de l'application. \newline
Les tests doivent couvrir le plus large panel de fonctionnalités possible. Selenium propose de sauvegarder différents tests sous forme de suite de tests. Il convient donc de diviser chacune des grandes fonctionnalités de l'application en suite de tests puis de sous-diviser ces suites en cas de test afin de faciliter la mise à jour ultérieure de ces tests.

\subsection{Intégration de Selenium au sein de Jenkins}
L'intégration de Selenium au sein de Jenkins est rendue possible grâce à l'utilisation du plugin Jenkins Selenium. Pour ce faire, il faut procéder à l'installation du plugin SeleniumHQ au sein de Jenkins. Ce plugin va nous permettre d'ajouter le lancement de tests au sein de la configuration du projet Jenkins. En outre, l'ajout du plugin Selenium HTML report permettra d'afficher les résultats des tests effetués par Selenium au sein de Jenkins.\newline
Afin de fonctionner, Selenium sera lancé par Jenkins via l'utilisation de Selenium Remote Control. Ce dernier permet de simuler l'action de Selenium IDE afin d'effectuer les tests. En effet, l'application Selenium IDE n'a nullement besoin d'être réellement lancée par l'utilisateur afin de procéder à l'exécution des tests, Selenium Remote Control agit comme l'application Selenium IDE sans que celle-ci n'ait été lancée auparavant par un AMOA.

\subsection{Intégration des tests au sein du pipeline}
Pour créer un pipeline sous Jenkins, l'ajout de la suite de plugin Pipeline est indispensable. Celle-ci contient tous les outils permettant d'utiliser les pipelines avec Jenkins en comprenant par exemple l'outil de gestion d'un script de pipeline as code par exemple mais aussi de visualiser le pipeline lors de son utilisation. Le script du pipeline doit spécifier l'ordre d'enchainement des étapes effectuées au sein de Jenkins et être intégralement présent au sein d'un seul Jenkinsfile par projet. Pour intégrer les tests Selenium au sein du pipeline, il demeure nécessaire de les intégrer au sein d'un fichier batch sous Windows ou shell sous Macintosh/Linux puis d'inclure leur exécution au sein du script du pipeline à l'étape souhaitée. \medbreak

Afin d'être efficace, les pipelines doivent être implémentés au sein de Jenkins pour chacun des environnements de travail, de l'environnement de développement jusqu'à l'environnement de production. En effet, le bon fonctionnement de l'application sur un environnement ne garantit pas que ce sera le cas sur une autre environnement. Les tests automatisés devront donc être executés sur l'environnement de recette et de pré-production afin de permettre de valider le comportement de l'application avant livraison au sein de l'environnement de production.
\medbreak
\begin{figure}[!h] 
\centerline{\includegraphics[scale=0.70]{pipelineSelenium.png}}
\caption{Exécution des tests Selenium au sein du pipeline}
\end{figure} 
\medbreak

\section{Limites de l'automatisation des tests d'acceptation}
Enjeux important dans l'optique de générer un gain de temps lors d'une livraison logicielle, l'automatisation des tests fonctionnels souffre aussi de défauts certains. Ceux-ci doivent en effet impérativement être pris en compte par une organisation désireuse de mettre en place une automatisation des tests d'acceptation car cette automatisation peut s'avérer coûteuse ou fastidieuse. \medbreak

\subsection{Une démarche coûteuse à mettre en place}
L'automatisation de la recette fonctionnelle peut s'avérer long à mettre en place. En effet, malgré le faible temps d'exécution des tests, leur création peut représenter un coût non négligeable pour l'entreprise car plus l'application comporte de fonctionnalités, plus le nombre de test à mettre en place est élevé. De nombreuses entreprises font donc le choix de réduire le temps consacré à la mise en place des tests automatisés d'acceptation \cite{19}. Il peut donc être judicieux de commencer par effectuer une sélection des tests qui seront à automatiser et les tests trop coûteux à mettre en place seraient ainsi toujours effectués manuellement.

\subsection{Le problème des changements dans l'interface}

En effet, étant basée sur l'interface graphique d'une application, l'automatisation connait des limites qui peuvent s'avérer assez lourdes dans le cas de projets régulièrement mis à jour \cite{4}. Les tests automatisés étant entièrement basés sur l'interface graphique du programme, si celle-ci vient à  changer, les tests s'avèrent totalement obsolètes. Ils devront être entièrement recréés. Il demeure donc indispensable de tenir très régulièrement à jour les tests dans le cas de changements survenant au niveau de l'interface ou bien si le dom, ou le xpath, des éléments est modifié au niveau du code, ce qui peut représenter une certaine perte de temps au sein d'un projet.\medbreak

\subsection{L'obligation de suivre les mises à jour des fonctionnalités}
Les tests automatisés de non-régression doivent aussi faire l'objet de mise à jour afin d'être fonctionnels. En effet, chacune des fonctionnalités implémentées au sein d'une application doit faire l'objet de création, ou de mises à jour, des tests automatisés. Ainsi il est impératif de veiller au fait que ceux-ci ne constituent pas une perte de temps trop significative dans le cadre de la bonne avancée d'un projet.\newline 
En outre, les changements d'exigences du client peuvent survenir fréquement, engendrant ainsi une modification du comportement de l'application, attenuant, voir annulant, l'utilité d'un test ou d'une suite de tests automatisés parfaitement fonctionnels jusqu'alors. Ainsi, le bénéfice de l'automatisation des tests dépend également du comportement adopté par le client. 

\subsection{Seule une écriture tardive demeure possible}
Effectuer les tests d'acceptation n'étant possible qu'une fois l'application développée, il en va de même pour leur automatisation. Ainsi, il est impossible d'utiliser une technique de développement comme le Test Driven Developpement \cite{20} qui consiste à mettre en place les tests unitaires avant de procéder à l'écriture du code d'une application.\newline
Les tests d'acceptation automatisés ne peuvent donc pas être écrits en amont ou en parallèle du développement et être ainsi utilisables dès la fin du développement d'une fonctionnalité. Le démarrage de leur écriture ne peut être débuté qu'après la finalisation du développement ce qui peut représenter une perte de temps dans l'avancée d'un projet. En effet, selon Cem Kaner \cite{21}, plus les bugs au sein d'une application sont trouvés tard, plus le coût de correction est élevé et le temps passé à écrire les tests retarde la recherche des bugs au sein de l'application. Ainsi, la mise en place des tests automatisés peut générer une perte de temps pour le projet.
